#  线性表
    
    线性表存储结构可细分为顺序存储结构（顺序表）和链式存储结构（链表）

# 数组

    参考文档：https://zhuanlan.zhihu.com/p/78094287
    
## 特性
    
    在内存中是一段连续的内存区域
        
    数组的访问效率高， 插入与删除效率低

## 复杂度
     
    访问：支持随机访问
        
        时间复杂度：
        
            O(1)： 通过下标去访问数据时并不需要遍历整个数组
            
            O(n)：遍历整个数组的元素
        
    插入/删除：
        
        数组中间插入一个新元素，就必须要将要相邻的后面的元素全部往后移动一个位置
        
        时间复杂度：
        
              O(n): 插入/删除在数组的最开头位置，那整个原始数组都需要向后移动一位
              
              O(1): 新元素要插入/删除的位置是最末尾，则无需其它元素移动   
    
# 链表

## 特性
    
    非连续、非顺序的存储结构
    
     用于插入与删除较为频繁的场景
                
     链表的每一个节点通过"指针"链接起来，每一个节点有2部分组成，一部分是数据，另一部分是后继指针（用来存储后一个节点的地址）
     
## 链表的种类
    
    1. 单向链表
        
        每一个节点只有一个指针指向后面一个节点
    
    2. 双向链表
        
        每一个节点都有2个指针，一个指向前节点，一个指向后节点
        
    3. 循环链表
    
        特殊的单向链表, 尾节点的指针指向了Head节点，使之首尾相连

## 复杂度
    
    访问：
        
        如果要查找某个节点，则需要一个节点一个节点的遍历
        
        时间复杂度： O(n)
        
    插入/删除： 
        
        对元素的插入和删除时，并不需要像数组那样移动其它元素，只需要修改指针的指向即可
        
        时间复杂度：
                    
            O(1)： 找到节点之后纯粹的插入或删除动作所需的时间复杂度
            
            O(n)： 未定位到指定的节点，只是拿到链表的Head
            
## 链表的实现
    
    参考文档：https://zhuanlan.zhihu.com/p/60057180
                 
# 跳跃表：
    
    多层次链表

    参考文档： https://zhuanlan.zhihu.com/p/68516038

## 时间复杂度

    
     时间复杂度：
     
        访问： O(longn)
        
             m 级索引，第 m 级的结点数为两个
             
             n/(2^m)=2，从而求得 m=log(n)-1， 加上原始链表，那么整个跳表的高度就是 log(n)
             
             最终的时间复杂度就为 O(k*log(n))
             
        
        插入/删除： O(longn)
                    
               跳表的查询的时间复杂度为 O(logn），因为找到位置之后插入和删除的时间复杂度很低，为 O(1)
               
## 空间复杂度：O(n)
            
     跳表的效率比链表高了，但是跳表需要额外存储多级索引，所以需要的更多的内存空间。
     
     n/2+n/4+n/8…+8+4+2=n-2
    
## 二分查找

    时间复杂度：O(logn)
    
    参考文档：https://baolei.blog.csdn.net/article/details/105715231


# 栈
     
    只能在一端进行插入和删除操作的特殊线性表
    
    参考文档：https://mp.weixin.qq.com/s/6DMLl_EksTqSqWyE2FkEug

## 栈的定义：
    
    先进后出，后进先出的结构称为"栈"
    
    PS：柜子只有一个出口和入口，而且出口和入口是一样的。
    
## 栈的实现：

    顺序栈： 基于数组的实现
    
    链式栈： 基于链表的实现    
    
    参考文档：https://www.pythonf.cn/read/82810
    
    
## 时间复杂度： O（1）
    
        顺序栈：
    
            出栈：O(1)
                
                出栈直接取尾部的数据
                
            入栈：平均复杂度O(1)
                
                入栈添加到尾部（前面数据的位置并未发生改变）
                
                当插入的操作在顺序栈的最大空间时,是O(1)
                
                当大于数组的长度时，这时候需要进行动态扩容， 动态扩容会重新申请一个更大的空间,并把原来的数据迁移过去,这时候的空间复杂度为O(n)
                
                入栈操作平均复杂度可以看做O(1),最好时间复杂度为O(1),最差的时间复杂度为O(n)
                
        链表栈：
            
            出栈：O(1)
            入栈：O(1)
        
## 空间复杂度： O（1）
        
      入栈和出栈需要一个临时空间来存储变量，空间复杂度为 O(1)
        
        
# 队列

    只能在一端进行插入操作，在另一端进行删除操作的特殊线性表

## 队列的定义

    先进先出：入队就是把数据放在队列尾部，出队就是把队列头部取一个元素。
    
## 队列的实现

    参考文档：https://zhuanlan.zhihu.com/p/81018602
    
    顺序队列：基于数组实现
    
    链式队列：基于链表实现 
    
    循环队列：前后连成一个圆圈，以循环的方式去存储元素
    
    优先队列：不遵守先进先出的原则，它是按照优先级出队列的。分为最大优先队列（是指最大的元素优先出队）和最小优先队列（是指最小的元素优先出队）
    
    普通数组队列的弊端：
    
        经过了一段时间的入队和出队以后，尾指针rear就指向了数组的最后位置了，没法再往队列里插入数据了，
        但是数组的前面部分（front的前面）由于旧的数据曾经出队了，所以会空出来一些空间，这些空间就没法利用起来
    
## 时间复杂度： O（1）
    
    顺序队列：
    
        出队、入队：O(1)
        
            无论是做入队操作还是出队操作，front或rear都是往后移动，并不会往前移动。
            入队的时候是rear往后移动，出队的时候是front往后移动。
            

